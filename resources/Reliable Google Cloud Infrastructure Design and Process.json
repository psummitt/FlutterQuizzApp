[
    {
        "title": "Using SMART criteria, which below would be the least effective KPI?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "user experience design is not measurable or time bound and so would not make a relevant KPI.",
        "options": [
            {
                "title": "Page views per hour",
                "correct": false
            },
            {
                "title": "Clicks per session",
                "correct": false
            },
            {
                "title": "User experience design",
                "correct": true
            },
            {
                "title": "User sign ups per month",
                "correct": false
            }
        ]
    },
    {
        "title": "Which most accurately describes a user story?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "it describes a feature from the user's point of view",
        "options": [
            {
                "title": "It is a short description of a feature written from the user's point of view.",
                "correct": true
            },
            {
                "title": "It is a short description of a typical person using the system.",
                "correct": false
            },
            {
                "title": "It is a narrative that describes the sequence of steps a typical user would perform to accomplish some task or goal when using the system.",
                "correct": false
            },
            {
                "title": "It is a requirement of the system you are developing.",
                "correct": false
            }
        ]
    },
    {
        "title": "Which best describes an SLO?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "Which best describes an SLO?",
        "options": [
            {
                "title": "It is a measurable, time bound key performance indicator for your application.",
                "correct": false
            },
            {
                "title": "It is a contract with end users that guarantees service quality",
                "correct": false
            },
            {
                "title": "It is a target measure you want your service to achieve.",
                "correct": true
            },
            {
                "title": "It is a short, measurable description of an application feature.",
                "correct": false
            }
        ]
    },
    {
        "title": "Which below would violate 12-factor app best practices?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "Code and config should be separated, because config varies across deployments but code does not. The true test is whether the repository could be open-sourced without compromising any credentials.",
        "options": [
            {
                "title": "Keep development, testing, and production as similar as possible.",
                "correct": false
            },
            {
                "title": "Explicitly declare and isolate dependencies.",
                "correct": false
            },
            {
                "title": "Treat logs as event streams and aggregate logs into a single source.",
                "correct": false
            },
            {
                "title": "Store configuration information in your source repository for easy versioning.",
                "correct": true
            }
        ]
    },
    {
        "title": "You’ve re-architected a monolithic web application so state is not stored in memory on the web servers, but in a database instead. This has caused slow performance when retrieving user sessions though. What might be the best way to fix this?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "Services should be stateless, and a service like Memorystore for Redis provides a fast caching service to store state. They enable services to be stateless and support scale and high availability.",
        "options": [
            {
                "title": "Use a caching service like Memorystore for Redis.",
                "correct": true
            },
            {
                "title": "Make sure all web servers are in the same zone as the database.",
                "correct": false
            },
            {
                "title": "Move session state back onto the web servers and use sticky sessions in the load balancer.",
                "correct": false
            },
            {
                "title": "Increase the number of CPUs in the database server.",
                "correct": false
            }
        ]
    },
    {
        "title": "You’re building a RESTful microservice. Which would be a valid data format for returning data to the client?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "They have a standard Content-Type that can be set on the response header and are text-based. It is usual to use JSON, but both XML and JSON are valid.",
        "options": [
            {
                "title": "XML",
                "correct": false
            },
            {
                "title": "All options are correct.",
                "correct": true
            },
            {
                "title": "JSON",
                "correct": false
            },
            {
                "title": "HTML",
                "correct": false
            }
        ]
    },
    {
        "title": "You’re writing a service, and you need to handle a client sending you invalid data in the request. What should you return from the service?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "400 is a HTTP status code indicating that a request could not be processed due to an apparent client error.",
        "options": [
            {
                "title": "A 200 error code",
                "correct": false
            },
            {
                "title": "A 500 error code",
                "correct": false
            },
            {
                "title": "A 400 error code",
                "correct": true
            },
            {
                "title": "An XML exception",
                "correct": false
            }
        ]
    },
    {
        "title": "Which Google Cloud tools can be used to build a continuous integration pipeline?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "All of the options are correct. Source Repositories provides a private Git repository, Cloud Build builds containers, and Container Registry is a Docker images repository that performs vulnerability analysis. All three components are typically used in a continuous integration pipeline where on a commit, code is built and tested and an image is built and published to a registry.",
        "options": [
            {
                "title": "Container Registry",
                "correct": false
            },
            {
                "title": "All of these",
                "correct": true
            },
            {
                "title": "Cloud Source Repositories",
                "correct": false
            },
            {
                "title": "Cloud Build",
                "correct": false
            }
        ]
    },
    {
        "title": "What Google Cloud feature would be easiest to use to automate a build in response to code being checked into your source code repository?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "Cloud Build triggers have been designed specifically to trigger a build automatically when changes are made to source code.",
        "options": [
            {
                "title": "CloudScheduler",
                "correct": false
            },
            {
                "title": "Cloud Functions",
                "correct": false
            },
            {
                "title": "AppEngine",
                "correct": false
            },
            {
                "title": "Build triggers",
                "correct": true
            }
        ]
    }
]