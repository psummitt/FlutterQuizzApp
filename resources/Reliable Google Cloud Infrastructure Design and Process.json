[
    {
        "title": "Using SMART criteria, which below would be the least effective KPI?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "user experience design is not measurable or time bound and so would not make a relevant KPI.",
        "options": [
            {
                "title": "Page views per hour",
                "correct": false
            },
            {
                "title": "Clicks per session",
                "correct": false
            },
            {
                "title": "User experience design",
                "correct": true
            },
            {
                "title": "User sign ups per month",
                "correct": false
            }
        ]
    },
    {
        "title": "Which most accurately describes a user story?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "it describes a feature from the user's point of view",
        "options": [
            {
                "title": "It is a short description of a feature written from the user's point of view.",
                "correct": true
            },
            {
                "title": "It is a short description of a typical person using the system.",
                "correct": false
            },
            {
                "title": "It is a narrative that describes the sequence of steps a typical user would perform to accomplish some task or goal when using the system.",
                "correct": false
            },
            {
                "title": "It is a requirement of the system you are developing.",
                "correct": false
            }
        ]
    },
    {
        "title": "Which best describes an SLO?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "Which best describes an SLO?",
        "options": [
            {
                "title": "It is a measurable, time bound key performance indicator for your application.",
                "correct": false
            },
            {
                "title": "It is a contract with end users that guarantees service quality",
                "correct": false
            },
            {
                "title": "It is a target measure you want your service to achieve.",
                "correct": true
            },
            {
                "title": "It is a short, measurable description of an application feature.",
                "correct": false
            }
        ]
    },
    {
        "title": "Which below would violate 12-factor app best practices?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "Code and config should be separated, because config varies across deployments but code does not. The true test is whether the repository could be open-sourced without compromising any credentials.",
        "options": [
            {
                "title": "Keep development, testing, and production as similar as possible.",
                "correct": false
            },
            {
                "title": "Explicitly declare and isolate dependencies.",
                "correct": false
            },
            {
                "title": "Treat logs as event streams and aggregate logs into a single source.",
                "correct": false
            },
            {
                "title": "Store configuration information in your source repository for easy versioning.",
                "correct": true
            }
        ]
    },
    {
        "title": "You’ve re-architected a monolithic web application so state is not stored in memory on the web servers, but in a database instead. This has caused slow performance when retrieving user sessions though. What might be the best way to fix this?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "Services should be stateless, and a service like Memorystore for Redis provides a fast caching service to store state. They enable services to be stateless and support scale and high availability.",
        "options": [
            {
                "title": "Use a caching service like Memorystore for Redis.",
                "correct": true
            },
            {
                "title": "Make sure all web servers are in the same zone as the database.",
                "correct": false
            },
            {
                "title": "Move session state back onto the web servers and use sticky sessions in the load balancer.",
                "correct": false
            },
            {
                "title": "Increase the number of CPUs in the database server.",
                "correct": false
            }
        ]
    },
    {
        "title": "You’re building a RESTful microservice. Which would be a valid data format for returning data to the client?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "They have a standard Content-Type that can be set on the response header and are text-based. It is usual to use JSON, but both XML and JSON are valid.",
        "options": [
            {
                "title": "XML",
                "correct": false
            },
            {
                "title": "All options are correct.",
                "correct": true
            },
            {
                "title": "JSON",
                "correct": false
            },
            {
                "title": "HTML",
                "correct": false
            }
        ]
    },
    {
        "title": "You’re writing a service, and you need to handle a client sending you invalid data in the request. What should you return from the service?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "400 is a HTTP status code indicating that a request could not be processed due to an apparent client error.",
        "options": [
            {
                "title": "A 200 error code",
                "correct": false
            },
            {
                "title": "A 500 error code",
                "correct": false
            },
            {
                "title": "A 400 error code",
                "correct": true
            },
            {
                "title": "An XML exception",
                "correct": false
            }
        ]
    },
    {
        "title": "Which Google Cloud tools can be used to build a continuous integration pipeline?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "All of the options are correct. Source Repositories provides a private Git repository, Cloud Build builds containers, and Container Registry is a Docker images repository that performs vulnerability analysis. All three components are typically used in a continuous integration pipeline where on a commit, code is built and tested and an image is built and published to a registry.",
        "options": [
            {
                "title": "Container Registry",
                "correct": false
            },
            {
                "title": "All of these",
                "correct": true
            },
            {
                "title": "Cloud Source Repositories",
                "correct": false
            },
            {
                "title": "Cloud Build",
                "correct": false
            }
        ]
    },
    {
        "title": "What Google Cloud feature would be easiest to use to automate a build in response to code being checked into your source code repository?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "Cloud Build triggers have been designed specifically to trigger a build automatically when changes are made to source code.",
        "options": [
            {
                "title": "CloudScheduler",
                "correct": false
            },
            {
                "title": "Cloud Functions",
                "correct": false
            },
            {
                "title": "AppEngine",
                "correct": false
            },
            {
                "title": "Build triggers",
                "correct": true
            }
        ]
    },
    {
        "title": "You are a global financial services company with users all over the world. You need a database service that can provide low latency worldwide with strong consistency. Which service might you choose?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "A key feature of Spanner is scale for relational data with strong consistency, and it is globally distributed to provide low latency. The high availability and automatic replication are also strong features for financial services.",
        "options": [
            {
                "title": "Spanner",
                "correct": true
            },
            {
                "title": "BigQuery",
                "correct": false
            },
            {
                "title": "Firestore",
                "correct": false
            },
            {
                "title": "Cloud SQL",
                "correct": false
            }
        ]
    },
    {
        "title": "Currently, you are using Firestore to store information about products, reviews, and user sessions. You'd like to speed up data access in a simple, cost-effective way. What would you recommend?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "Memorystore provides the best fit when considering data model, performance, scale, cost, and availability.",
        "options": [
            {
                "title": "Cache the data using Memorystore.",
                "correct": true
            },
            {
                "title": "Move the data to BigQuery.",
                "correct": false
            },
            {
                "title": "Move the data to Spanner.",
                "correct": false
            },
            {
                "title": "Move the data to Cloud Bigtable.",
                "correct": false
            }
        ]
    },
    {
        "title": "You need to store user preferences, product information, and reviews for a website you are building. There won't be a huge amount of data. What would be a simple, cost-effective, managed solution?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "Firestore provides automatic scale ACID transactions and live synchronization and is integrated with Google Cloud and Firebase. It also has a free tier.",
        "options": [
            {
                "title": "Cloud SQL",
                "correct": false
            },
            {
                "title": "Spanner",
                "correct": false
            },
            {
                "title": "Firestore",
                "correct": true
            },
            {
                "title": "BigQuery",
                "correct": false
            }
        ]
    },
    {
        "title": "You want to analyze sales trends. To help achieve this, you want to combine data from your on-premises Oracle database with Google Analytics data and your web server logs. Where might you store the data so it is both easy to query and cost-effective?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "BigQuery is a data warehouse used for data analytics, and so is built for this type of use case. It provides the infrastructure to ingest data from many different sources, which is a requirement too. The cost model of paying for storage and then only for queries run is attractive too.",
        "options": [
            {
                "title": "Cloud SQL",
                "correct": false
            },
            {
                "title": "BigQuery",
                "correct": true
            },
            {
                "title": "Firestore",
                "correct": false
            },
            {
                "title": "Spanner",
                "correct": false
            }
        ]
    },
    {
        "title": "You are deploying a large-scale web application with users all over the world and a lot of static content. Which load balancer configuration would likely be the most suitable?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "the traffic is HTTP(S), the load balancer should be external and global, and CDN enabled will help performance and cost.",
        "options": [
            {
                "title": "HTTP load balancer with SSL configured.",
                "correct": false
            },
            {
                "title": "TCP load balancer with SSL configured.",
                "correct": false
            },
            {
                "title": "UDP load balancer with SSL configured and the CDN enabled.",
                "correct": false
            },
            {
                "title": "HTTP load balancer with SSL configured and the CDN enabled.",
                "correct": true
            }
        ]
    },
    {
        "title": "You want a secure, private connection between your network and a Google Cloud network. There is not a lot of volume, but the connection needs to be extremely reliable. Which configuration below would you choose?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "this offers a secure extremely reliable connection and is more cost-effective than Cloud Interconnect.",
        "options": [
            {
                "title": "Cloud Interconnect",
                "correct": false
            },
            {
                "title": "VPN",
                "correct": false
            },
            {
                "title": "VPC peering",
                "correct": false
            },
            {
                "title": "VPN with high availability and Cloud Router.",
                "correct": true
            }
        ]
    },
    {
        "title": "You are a large bank deploying an online banking service to Google Cloud. The service needs high volume access to mainframe data on-premises. Which connectivity option would likely be most suitable?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": " Cloud Interconnect provides high bandwidth and low latency. It does need encryption at the application level.",
        "options": [
            {
                "title": "Cloud Interconnect",
                "correct": true
            },
            {
                "title": "HTTPS",
                "correct": false
            },
            {
                "title": "VPN",
                "correct": false
            },
            {
                "title": "Peering",
                "correct": false
            }
        ]
    },
    {
        "title": "You have a contract with a service provider to manage your Google VPC networks. You want to connect a network they own to your VPC. Both networks are in Google Cloud. Which Connection option should you choose?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "VPC peering allows connectivity across two VPC networks regardless of whether they belong to the same project or same organization.",
        "options": [
            {
                "title": "VPN with high availability and Cloud Router.",
                "correct": false
            },
            {
                "title": "VPC peering",
                "correct": true
            },
            {
                "title": "VPN",
                "correct": false
            },
            {
                "title": "Cloud Interconnect",
                "correct": false
            }
        ]
    },
    {
        "title": "You need to deploy an existing application that was written in .NET version 4. The application requires Windows servers, and you don't want to change it. Which should you use?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "the approach is a lift-and-shift, which is best supported by Compute Engine because Compute Engine offers full control over virtual machines including operating systems. No repackaging would be required.",
        "options": [
            {
                "title": "App Engine",
                "correct": false
            },
            {
                "title": "Compute Engine",
                "correct": true
            },
            {
                "title": "GKE",
                "correct": false
            },
            {
                "title": "Cloud Functions",
                "correct": false
            }
        ]
    },
    {
        "title": "You've been asked to write a program that uses Vision API to check for inappropriate content in photos that are uploaded to a Cloud Storage bucket. Any photos that are inappropriate should be deleted. What might be the simplest, cheapest way to deploy in this program?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "the requirements for simplest and cheapest are met with Cloud Functions. Cloud Functions are for single purpose functions like image analysis. Cloud Functions also can be triggered by Cloud Storage events, so they provide seamless integration. The payment model based on number of requests, processing time of request (measured in 100ms units), and then other resources consumed is the most suitable of all options offered above. There is a free tier too. Cloud Functions also provides automatic scaling, high availability, and fault tolerance.",
        "options": [
            {
                "title": "Compute Engine",
                "correct": false
            },
            {
                "title": "App Engine",
                "correct": false
            },
            {
                "title": "GKE",
                "correct": false
            },
            {
                "title": "Cloud Functions",
                "correct": true
            }
        ]
    },
    {
        "title": "You have containerized multiple applications using Docker and have deployed them using Compute Engine VMs. You want to save on costs and simplify container management. What might you do?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "The applications are containerized, and GKE will help with the resource efficiency and hence cost, automate many aspects of the container management, and provide the best solution for the scenario.",
        "options": [
            {
                "title": "Rewrite the applications to run in Cloud Functions.",
                "correct": false
            },
            {
                "title": "Write Terraform scripts for all deployment.",
                "correct": false
            },
            {
                "title": "Rewrite the applications to run in App Engine standard environment.",
                "correct": false
            },
            {
                "title": "Migrate the containers to GKE.",
                "correct": true
            }
        ]
    },
    {
        "title": "You're creating a service and you want to protect it from being overloaded by too many client retries in the event of a partial outage. Which design pattern would you implement?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": " the circuit breaker will attempt to prevent an operation that is likely to fail and therefore will protect the resource that is in partial outage and hopefully prevent cascading failure.",
        "options": [
            {
                "title": "Circuit breaker",
                "correct": true
            },
            {
                "title": "Truncated exponential backoff",
                "correct": false
            },
            {
                "title": "Overload feedback repudiation",
                "correct": false
            },
            {
                "title": "Lazy caching",
                "correct": false
            }
        ]
    },
    {
        "title": "You need a relational database for a system that requires extremely high availability (99.999%). The system must run uninterrupted even in the event of a regional outage. Which database would you choose?",
        "imagePath": "",
        "optionType": "singleChoice",
        "notes": "some notes on this question",
        "supportiveInfo": "Cloud Spanner meets all the requirements. It is a global relational database with high availability. Multi-regional instances have a monthly uptime of >=99.999%.",
        "options": [
            {
                "title": "BigQuery",
                "correct": false
            },
            {
                "title": "Spanner",
                "correct": true
            },
            {
                "title": "Cloud SQL",
                "correct": false
            },
            {
                "title": "Firestore",
                "correct": false
            }
        ]
    }
]